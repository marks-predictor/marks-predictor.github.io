<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WBJEE GMR Predictor</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container">
    <h1>ðŸ“Š WBJEE GMR Predictor</h1>
    <p>Enter your total marks (out of 200):</p>
    <input type="number" id="marks" placeholder="e.g., 123" />
    <button onclick="predictGMR()">Predict GMR</button>
    <div id="output"></div>
  </div>

  <script>
    async function predictGMR() {
      const marks = parseFloat(document.getElementById('marks').value);
      const output = document.getElementById('output');
      output.innerHTML = '';

      if (isNaN(marks) || marks < 0 || marks > 200) {
        output.innerHTML = '<p style="color: red;">Enter valid marks between 0 and 200.</p>';
        return;
      }

      const res = await fetch('data/gmr_data.json');
      const data = await res.json();

      const pastYears = ['2022', '2023', '2024'];
      let combinedData = [];

      pastYears.forEach(year => {
        combinedData = combinedData.concat(data[year]);
      });

      combinedData.sort((a, b) => a.marks - b.marks);

      let lower = null, upper = null;

      for (let i = 0; i < combinedData.length; i++) {
        if (combinedData[i].marks <= marks) lower = combinedData[i];
        if (combinedData[i].marks >= marks) {
          upper = combinedData[i];
          break;
        }
      }

      let estimatedMin = null, estimatedMax = null;

      if (lower && upper && lower.marks !== upper.marks) {
        const slope = (upper.gmr - lower.gmr) / (upper.marks - lower.marks);
        const est = lower.gmr + slope * (marks - lower.marks);
        const buffer = Math.max(10, Math.abs(upper.gmr - lower.gmr) * 0.15);
        estimatedMin = Math.max(1, Math.round(est - buffer));
        estimatedMax = Math.round(est + buffer);
      } else if (lower) {
        const buffer = Math.max(30, lower.gmr * 0.08);
        estimatedMin = Math.max(1, Math.round(lower.gmr - buffer));
        estimatedMax = Math.round(lower.gmr + buffer);
      } else if (upper) {
        const buffer = Math.max(30, upper.gmr * 0.08);
        estimatedMin = Math.max(1, Math.round(upper.gmr - buffer));
        estimatedMax = Math.round(upper.gmr + buffer);
      }

      // âœ… Show AI prediction for 2025
      output.innerHTML += `<h2>ðŸ”® AI Estimated GMR for 2025</h2>`;
      output.innerHTML += `<ul><li><strong>Estimated GMR:</strong> <strong>${estimatedMin} â€“ ${estimatedMax}</strong></li>`;
      output.innerHTML += `<li>Based on trends from 2022, 2023, and 2024</li></ul>`;

      // ðŸ“Š Show actual past years' marks within Â±2 marks
      output.innerHTML += `<h2>ðŸ“Š Real Data Matches (Â±2 Marks)</h2>`;

      for (const year of pastYears) {
        const matches = data[year]
          .filter(p => Math.abs(p.marks - marks) <= 2)
          .sort((a, b) => a.marks - b.marks);

        if (matches.length > 0) {
          output.innerHTML += `<div class="year-block"><p><strong>ðŸ”¹ ${year}</strong></p><ul>`;
          matches.forEach(p => {
            const diff = marks - p.marks;
            const status =
              diff > 2 ? `ðŸŸ¢ Higher than ${p.marks} marks (GMR ${p.gmr})`
              : diff < -2 ? `ðŸ”´ Lower than ${p.marks} marks (GMR ${p.gmr})`
              : `ðŸŸ¡ Very close to ${p.marks} marks (GMR ${p.gmr})`;
            output.innerHTML += `<li>Marks: ${p.marks} â†’ GMR: ${p.gmr}<br>${status}</li>`;
          });
          output.innerHTML += `</ul></div>`;
        }
      }
    }
  </script>
</body>
</html>
