<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WBJEE GMR Predictor</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container">
    <h1>ðŸ“Š WBJEE GMR Predictor</h1>
    <p>Enter your total marks (out of 200):</p>
    <input type="number" id="marks" placeholder="e.g., 123" />
    <button onclick="predictGMR()">Predict GMR</button>
    <div id="output"></div>
  </div>

  <script>
    async function predictGMR() {
      const marks = parseFloat(document.getElementById('marks').value);
      const output = document.getElementById('output');
      output.innerHTML = '';

      if (isNaN(marks) || marks < 0 || marks > 200) {
        output.innerHTML = '<p style="color: red;">Enter valid marks between 0 and 200.</p>';
        return;
      }

      const res = await fetch('data/gmr_data.json');
      const data = await res.json();

      const pastYears = ['2022', '2023', '2024'];
      let combinedData = [];

      pastYears.forEach(year => {
        combinedData = combinedData.concat(data[year]);
      });

      combinedData.sort((a, b) => a.marks - b.marks);

      let lower = null, upper = null;

      for (let i = 0; i < combinedData.length; i++) {
        if (combinedData[i].marks <= marks) lower = combinedData[i];
        if (combinedData[i].marks >= marks) {
          upper = combinedData[i];
          break;
        }
      }

      let estimatedMin = null, estimatedMax = null;

      if (lower && upper && lower.marks !== upper.marks) {
        const slope = (upper.gmr - lower.gmr) / (upper.marks - lower.marks);
        const est = lower.gmr + slope * (marks - lower.marks);
        const buffer = Math.max(10, Math.abs(upper.gmr - lower.gmr) * 0.15);
        estimatedMin = Math.max(1, Math.round(est - buffer));
        estimatedMax = Math.round(est + buffer);
      } else if (lower) {
        const buffer = Math.max(30, lower.gmr * 0.08);
        estimatedMin = Math.max(1, Math.round(lower.gmr - buffer));
        estimatedMax = Math.round(lower.gmr + buffer);
      } else if (upper) {
        const buffer = Math.max(30, upper.gmr * 0.08);
        estimatedMin = Math.max(1, Math.round(upper.gmr - buffer));
        estimatedMax = Math.round(upper.gmr + buffer);
      }

      // âœ… Show AI prediction for 2025
      output.innerHTML += `<h2>ðŸ”® AI Estimated GMR for 2025</h2>`;
      output.innerHTML += `<ul><li><strong>Estimated GMR:</strong> <strong>${estimatedMin} â€“ ${estimatedMax}</strong></li>`;
      output.innerHTML += `<li>Based on patterns from 2022, 2023, and 2024</li></ul>`;

      // ðŸ“Š Show actual past years' marks for similar GMRs
      output.innerHTML += `<h2>ðŸ“Š Actual Marks for Similar Ranks (Past Years)</h2>`;

      for (const year of pastYears) {
        const points = data[year].slice().sort((a, b) => a.gmr - b.gmr);
        const match = points.find(p => p.gmr >= estimatedMin - 2 && p.gmr <= estimatedMax + 2);

        if (match) {
          const diff = marks - match.marks;
          let status = '';
          if (diff > 2) {
            status = `ðŸŸ¢ Higher than GMR ${match.gmr} in ${year} by ${diff.toFixed(2)} marks`;
          } else if (diff < -2) {
            status = `ðŸ”´ Lower than GMR ${match.gmr} in ${year} by ${Math.abs(diff).toFixed(2)} marks`;
          } else {
            status = `ðŸŸ¡ Almost equal to GMR ${match.gmr} in ${year}`;
          }

          output.innerHTML += `<h3>${year}</h3><ul>`;
          output.innerHTML += `<li>GMR ${match.gmr} â†’ ${match.marks} marks â†’ ${status}</li></ul>`;
        }
      }
    }
  </script>
</body>
</html>
